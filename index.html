<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ScheduleBuddy</title>
    
    <!-- PWA Meta Tags for iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ScheduleBuddy">
    <meta name="theme-color" content="#1a1a1a">
    
    <!-- App Icon -->
    <link rel="apple-touch-icon" sizes="180x180" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAYAAAA9zQYyAAAGHUlEQVR4nO3d6XIbRRiFYV+H7x9IgCQQ7/sS7/uSACkgLAGpuAhNQ2t6zFgeWx7NSF/30dtVz6+YVNf4LZcji+OZmcjP7OysQzyse4j+WH+CQPCNjvUDB4E3PtYPFXGw7rDxsX6AiJN1l7WP9QNDGqw7HXqsHxDSZN1t5bF+KEibdb93x/pBQAsxQw4xQw4xQw4xQw4xQw4xQw4xQw4xQw5BQwoxQw4xQw5BQwoxQw5BQwoxQw5BQwoxQw5BQwpBQwoxQw5BQwpBQwpBQwoxQw5BQwpBQwpBQwpBQwpBQwpBQwpBQwoxQw5BQwpBQwpBQ4ps0P98cHes74LJkQy6+z67FzRRTw+5oP++yVznNnsQtfW9MBlSQX++ytxf11ll1NZ3w2TIBP37Reb+vMwqo7a+GyZHIuhPZ5n77TyrjNr6bpis5IP+5SRzv55mlVFb3w2Tl3TQH48y9/NxVhl107977stO37z3VccteC86brHwsuOWvK87bjlYCVa/ya153+bWvVfB647bCDbfBN913Faw/X1u521u15vruHd93b49b77r9gsLuYPF3KG3lDtazh17K1134q123WlhrevOgvP13EXZRtddepu5K2+r66697a67+Y91C+ZB7y307ozy3/94kLmfDrPKqBuF/EUnR9C1gvZud+zDNgm6HLN3sFQv6g97PffDflYZddO7ETRBNwrax3y00nMna8+L+na3596/61VG3VrMBD1y0NZRmwZdjvl8o+cut56O+mq75653epVRt3U3guYr9EiqYvax+lCrPv5iM/+YqqjbvBdBE/TIqmL2X3H9txDljztbzz+uKupx3Y2geZVjJFUx+3/g+Vcs/J8fr+Zfxauitr474mMetFcVs389+XA5/7akKmrrOyNOUQTtDca8v5j/o7Eqauu7Il7RBO0VMRevglRFbX1HxC2qoD3/Pozy69TlqK3vhvhFF7Q3+JNEH7X1nZCGKIP2mr7XA9Mp2qCBURA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pCQVtN/usL4D4hZ90H5U5no7n/3yQX8M+x2fTokbD0Ud9Ola78mg/2hhqR9aog36eKX3rKDH9btU5sJI43x5pPGRgca7ccZimHFwlHFgkPHBGONcMcY4MMIYBhj3iwHGwfHFweHFYnRxcHBxIwwuFmOLpaFF68/zVATth2XqBN1p8bdd3ZvSnYKg+1O4EczgEjRBEzRBPyPmKQ06hrFyyaCLX1VRN+i2fv3xtAZt/XmXDdrjWw6CJuiW7zAtQVt/rgl6QkEjTVEG7Vm/Do00RRu0x08KUVfUQXu8lwN1RB90Ge+2wzBJBQ0MQ9CQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQklTQ/F/fGCb6oNnlQB1RB81yEuqKNmjrbbv++mhYIF0oL5C+CAukL+8vkPZXSMMS6VpYIl0vL5G+Ckukr8MS6Zt8ibS/RhoWSXfCIunu22KNtLRIOhcWSUurpAfFKmlYJj0Ky6TH5WXSlbBMuhqWSdfyZdJ766RhofQyLJReBddhpfQmoZXSKIM234cOG9EE/X/QXgor/wRN0AStGvRdzAT9aNCxRx1d0FH8jhWC5it0m/iWg6AJuuU7EDSvckgFjTRFGbRn/To00hRt0B4/KURdUQft8V4O1BF90GW82w7DJBU0MAxBQwpBQwpBQwpBQwpBQ8qMP9aXANowUxzriwBtIGhIIWhIIWhIIWhIIWhIIWhImSkf68sATcwMHusLAU0QNKQQNKQ8CJqokarKmAkaqSJoSHk0aKJGap6MmaCRmqFBEzVS8ayYCRqpeHbQRI3Y1YqZoBG72kETNWI1UsxEjRg1ipmgEZvGQRM1YtFKzESNGLQaM1HD0lhiJmpYGGvMRI1JmkjMRI1JmGjMRI1xMomZqDEOpjGXj/WDQNqs+6081g8FabLuduixfkBIg3WntY/1A0OcrLtsfKwfIOJg3eFYjvVDBRGP9Vg/cBDwRI/1JwhpBfsvpDQUgRmjwc8AAAAASUVORK5CYII=">
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAYAAAA9zQYyAAAGHUlEQVR4nO3d6XIbRRiFYV+H7x9IgCQQ7/sS7/uSACkgLAGpuAhNQ2t6zFgeWx7NSF/30dtVz6+YVNf4LZcji+OZmcjP7OysQzyse4j+WH+CQPCNjvUDB4E3PtYPFXGw7rDxsX6AiJN1l7WP9QNDGqw7HXqsHxDSZN1t5bF+KEibdb93x/pBQAsxQw4xQw4xQw4xQw4xQw4xQw4xQw4xQw5BQwoxQw4xQw5BQwoxQw5BQwoxQw5BQwoxQw5BQwpBQwoxQw5BQwpBQwpBQwoxQw5BQwpBQwpBQwpBQwpBQwpBQwpBQwoxQw5BQwpBQwpBQ4ps0P98cHes74LJkQy6+z67FzRRTw+5oP++yVznNnsQtfW9MBlSQX++ytxf11ll1NZ3w2TIBP37Reb+vMwqo7a+GyZHIuhPZ5n77TyrjNr6bpis5IP+5SRzv55mlVFb3w2Tl3TQH48y9/NxVhl107977stO37z3VccteC86brHwsuOWvK87bjlYCVa/ya153+bWvVfB647bCDbfBN913Faw/X1u521u15vruHd93b49b77r9gsLuYPF3KG3lDtazh17K1134q123WlhrevOgvP13EXZRtddepu5K2+r66697a67+Y91C+ZB7y307ozy3/94kLmfDrPKqBuF/EUnR9C1gvZud+zDNgm6HLN3sFQv6g97PffDflYZddO7ETRBNwrax3y00nMna8+L+na3596/61VG3VrMBD1y0NZRmwZdjvl8o+cut56O+mq75653epVRt3U3guYr9EiqYvax+lCrPv5iM/+YqqjbvBdBE/TIqmL2X3H9txDljztbzz+uKupx3Y2geZVjJFUx+3/g+Vcs/J8fr+Zfxauitr474mMetFcVs389+XA5/7akKmrrOyNOUQTtDca8v5j/o7Eqauu7Il7RBO0VMRevglRFbX1HxC2qoD3/Pozy69TlqK3vhvhFF7Q3+JNEH7X1nZCGKIP2mr7XA9Mp2qCBURA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pBA0pCQVtN/usL4D4hZ90H5U5no7n/3yQX8M+x2fTokbD0Ud9Ola78mg/2hhqR9aog36eKX3rKDH9btU5sJI43x5pPGRgca7ccZimHFwlHFgkPHBGONcMcY4MMIYBhj3iwHGwfHFweHFYnRxcHBxIwwuFmOLpaFF68/zVATth2XqBN1p8bdd3ZvSnYKg+1O4EczgEjRBEzRBPyPmKQ06hrFyyaCLX1VRN+i2fv3xtAZt/XmXDdrjWw6CJuiW7zAtQVt/rgl6QkEjTVEG7Vm/Do00RRu0x08KUVfUQXu8lwN1RB90Ge+2wzBJBQ0MQ9CQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQQtCQklTQ/F/fGCb6oNnlQB1RB81yEuqKNmjrbbv++mhYIF0oL5C+CAukL+8vkPZXSMMS6VpYIl0vL5G+Ckukr8MS6Zt8ibS/RhoWSXfCIunu22KNtLRIOhcWSUurpAfFKmlYJj0Ky6TH5WXSlbBMuhqWSdfyZdJ766RhofQyLJReBddhpfQmoZXSKIM234cOG9EE/X/QXgor/wRN0AStGvRdzAT9aNCxRx1d0FH8jhWC5it0m/iWg6AJuuU7EDSvckgFjTRFGbRn/To00hRt0B4/KURdUQft8V4O1BF90GW82w7DJBU0MAxBQwpBQwpBQwpBQwpBQ8qMP9aXANowUxzriwBtIGhIIWhIIWhIIWhIIWhIIWhImSkf68sATcwMHusLAU0QNKQQNKQ8CJqokarKmAkaqSJoSHk0aKJGap6MmaCRmqFBEzVS8ayYCRqpeHbQRI3Y1YqZoBG72kETNWI1UsxEjRg1ipmgEZvGQRM1YtFKzESNGLQaM1HD0lhiJmpYGGvMRI1JmkjMRI1JmGjMRI1xMomZqDEOpjGXj/WDQNqs+6081g8FabLuduixfkBIg3WntY/1A0OcrLtsfKwfIOJg3eFYjvVDBRGP9Vg/cBDwRI/1JwhpBfsvpDQUgRmjwc8AAAAASUVORK5CYII=">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-gradient-start: #f5f0eb;
            --bg-gradient-end: #ede6df;
            --card-bg: white;
            --text-primary: #333;
            --text-secondary: #666;
            --text-tertiary: #999;
            --border-color: #e8e8e8;
            --input-bg: #f8f9fa;
            --completed-bg: #e8f5e9;
        }

        body.dark-mode {
            --bg-gradient-start: #1a1a1a;
            --bg-gradient-end: #141414;
            --card-bg: #2a2a2a;
            --text-primary: #e8e8e8;
            --text-secondary: #a0a0a0;
            --text-tertiary: #6b6b6b;
            --border-color: #3a3a3a;
            --input-bg: #222222;
            --completed-bg: #1a3a2a;
        }
        body.dark-mode .task-recurring {
            background: #1e2a3a;
            color: #6ea8c7;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            padding: calc(24px + env(safe-area-inset-top)) 24px 24px;
            padding-bottom: calc(90px + env(safe-area-inset-bottom));
            transition: background 0.3s ease;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
        }

        .header {
            background: var(--card-bg);
            border-radius: 18px;
            padding: 28px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: background 0.3s ease;
        }

        .user-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .level-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .level-badge {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 20px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .level-details h2 {
            font-size: 18px;
            color: var(--text-primary);
        }

        .level-details p {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .points {
            text-align: right;
        }

        .points-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .points-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .progress-bar {
            background: var(--border-color);
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .streak-info {
            display: flex;
            justify-content: space-around;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
        }

        .streak-item {
            text-align: center;
        }

        .streak-number {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .streak-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .section {
            background: var(--card-bg);
            border-radius: 18px;
            padding: 28px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: background 0.3s ease;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            letter-spacing: -0.3px;
        }

        .add-button {
            background: #5568d3;
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
            letter-spacing: 0.3px;
        }
        
        .add-button:hover {
            background: #4557c2;
            transform: translateY(-1px);
        }

        .task-list {
            list-style: none;
        }

        /* ‚îÄ‚îÄ Timeline: connected pill layout ‚îÄ‚îÄ */
        .timeline-wrapper {
            padding: 10px 0 24px;
        }
        .timeline {
            display: flex;
            flex-direction: column;
        }
        .timeline-row {
            display: flex;
            align-items: stretch;
            min-height: 72px;
        }
        /* left gutter: time label */
        .timeline-label-col {
            width: 48px;
            flex-shrink: 0;
            display: flex;
            align-items: flex-start;
            padding-top: 10px;
            justify-content: flex-end;
            padding-right: 10px;
        }
        .timeline-label {
            font-size: 11px;
            color: var(--text-tertiary);
            font-weight: 500;
            white-space: nowrap;
        }
        /* center column: connector + pill */
        .timeline-connector-col {
            width: 36px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        .timeline-line-seg {
            flex: 1;
            width: 2px;
            background: var(--border-color, #3a3a3a);
        }
        .timeline-pill {
            width: 32px;
            min-height: 48px;
            border-radius: 16px;
            background: #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            position: relative;
            z-index: 1;
        }
        .timeline-pill.completed {
            background: #667eea55;
        }
        .timeline-pill-icon {
            font-size: 18px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* ‚îÄ‚îÄ Icon trigger button (next to task name input) ‚îÄ‚îÄ */
        .name-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }
        .name-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }
        .icon-trigger {
            width: 46px;
            height: 46px;
            border-radius: 12px;
            border: 2px solid var(--border-color);
            background: var(--input-bg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            flex-shrink: 0;
            -webkit-tap-highlight-color: transparent;
            transition: border-color 0.15s;
        }
        .icon-trigger:active {
            border-color: #667eea;
        }
        /* ‚îÄ‚îÄ Icon popup sheet ‚îÄ‚îÄ */
        .icon-popup-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            z-index: 2000;
            display: none;
        }
        .icon-popup-overlay.show { display: block; }
        .icon-popup {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--card-bg);
            border-radius: 20px 20px 0 0;
            padding: 12px 24px 34px;
            z-index: 2001;
            transform: translateY(100%);
            transition: transform 0.28s cubic-bezier(.4,0,.2,1);
        }
        .icon-popup.show { transform: translateY(0); }
        .icon-popup-handle {
            width: 36px;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            margin: 0 auto 18px;
        }
        .icon-popup-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 6px;
        }
        .icon-popup-btn {
            aspect-ratio: 1;
            border-radius: 10px;
            border: 2px solid transparent;
            background: transparent;
            font-size: 22px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            transition: background 0.12s, border-color 0.12s;
        }
        .icon-popup-btn:active {
            background: rgba(102,126,234,0.1);
        }
        .icon-popup-btn.selected {
            border-color: #667eea;
            background: rgba(102,126,234,0.12);
        }
        .icon-popup-btn.clear-btn {
            font-size: 15px;
            color: var(--text-tertiary);
        }
        /* right: task content */
        .timeline-content-col {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0 10px 12px;
            gap: 10px;
        }
        .timeline-content-left {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }
        .timeline-meta {
            font-size: 11px;
            color: var(--text-tertiary);
            white-space: nowrap;
        }
        .timeline-task-name {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .timeline-row.completed .timeline-task-name {
            color: var(--text-tertiary);
            text-decoration: line-through;
        }
        .timeline-task-sub {
            font-size: 11px;
            color: var(--text-tertiary);
            margin-top: 1px;
        }
        /* far right: completion circle */
        .timeline-circle {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            border: 2px solid #667eea;
            background: transparent;
            flex-shrink: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        .timeline-circle.completed {
            background: #667eea;
        }
        .task-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 18px;
            background: var(--input-bg);
            border-radius: 14px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
            border: 1px solid var(--border-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
        }
        
        .task-item:hover {
            border-color: var(--text-tertiary);
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        }

        .task-item.completed {
            opacity: 0.6;
            background: var(--completed-bg);
        }

        .task-checkbox {
            width: 24px;
            height: 24px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .task-content {
            flex: 1;
        }

        .task-name {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .task-item.completed .task-name {
            text-decoration: line-through;
        }

        .task-points {
            font-size: 12px;
            color: #667eea;
            font-weight: 500;
        }

        .task-delete {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
        }

        /* ‚îÄ‚îÄ 2-column grid view ‚îÄ‚îÄ */
        .grid-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .grid-card {
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 14px;
            padding: 14px 12px 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 130px;
            position: relative;
            -webkit-tap-highlight-color: transparent;
        }
        .grid-card.completed {
            opacity: 0.5;
            background: var(--completed-bg);
        }
        .grid-card-top {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 6px;
        }
        .grid-card-icon {
            font-size: 22px;
            line-height: 1;
            flex-shrink: 0;
        }
        .grid-card-circle {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #667eea;
            background: transparent;
            flex-shrink: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        .grid-card-circle.completed {
            background: #667eea;
        }
        .grid-card-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            line-height: 1.3;
            flex: 1;
        }
        .grid-card.completed .grid-card-name {
            text-decoration: line-through;
            color: var(--text-tertiary);
        }
        .grid-card-meta {
            font-size: 11px;
            color: var(--text-tertiary);
        }
        .grid-card-xp {
            font-size: 11px;
            color: #667eea;
            font-weight: 500;
            margin-top: auto;
        }

        /* ‚îÄ‚îÄ View selector in settings ‚îÄ‚îÄ */
        .view-selector {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            margin-bottom: 4px;
        }
        .view-sel-btn {
            flex: 1;
            padding: 10px 6px;
            border-radius: 10px;
            border: 2px solid var(--border-color);
            background: var(--input-bg);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            text-align: center;
            transition: all 0.15s;
            -webkit-tap-highlight-color: transparent;
        }
        .view-sel-btn .sel-icon {
            font-size: 18px;
            display: block;
            margin-bottom: 4px;
        }
        .view-sel-btn:active {
            transform: scale(0.95);
        }
        .view-sel-btn.active {
            border-color: #667eea;
            background: rgba(102,126,234,0.12);
            color: #667eea;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .input-group input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            font-size: 16px;
            background: var(--input-bg);
            color: var(--text-primary);
            transition: border-color 0.2s ease;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group button {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 500;
        }

        .achievements {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .achievement {
            text-align: center;
            padding: 10px 4px;
            background: var(--input-bg);
            border-radius: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
            border: 1px solid transparent;
        }
        
        .achievement:hover {
            border-color: var(--border-color);
            transform: translateY(-2px);
        }

        .achievement.unlocked {
            background: linear-gradient(135deg, #ffd89b, #19547b);
            color: white;
            border-color: transparent;
        }

        .achievement-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .achievement-name {
            font-size: 10px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .achievement.unlocked .achievement-name {
            color: white;
        }

        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--card-bg);
            display: flex;
            justify-content: space-around;
            padding: 12px 0 calc(12px + env(safe-area-inset-bottom));
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -2px 12px rgba(0,0,0,0.08);
            transition: background 0.3s ease;
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            color: var(--text-tertiary);
            font-size: 12px;
            transition: color 0.3s ease;
        }

        .nav-item.active {
            color: #667eea;
        }

        .nav-icon {
            font-size: 24px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .celebration {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-bg);
            padding: 40px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .celebration.show {
            display: block;
            animation: popIn 0.5s ease;
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .celebration-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .celebration h3 {
            font-size: 24px;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .celebration p {
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        .celebration button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 500;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            z-index: 999;
        }

        .overlay.show {
            display: block;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-tertiary);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-bg);
            padding: 32px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            display: none;
            z-index: 1000;
            max-width: 400px;
            width: 90%;
        }

        .modal.show {
            display: block;
        }

        .modal h3 {
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 500;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-secondary {
            background: var(--border-color);
            color: var(--text-primary);
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .form-group input[type="time"] {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            background: var(--input-bg);
            color: var(--text-primary);
            transition: border-color 0.2s ease;
        }

        .form-group input[type="time"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 12px;
            margin-bottom: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .checkbox-group label {
            color: var(--text-primary);
            font-size: 14px;
            cursor: pointer;
        }

        .task-recurring {
            display: inline-block;
            background: #e3f2fd;
            color: #1976d2;
            padding: 2px 8px;
            border-radius: 6px;
            font-size: 11px;
            margin-left: 8px;
        }

        .day-selector {
            display: none;
            gap: 6px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .day-selector.visible {
            display: flex;
        }
        .day-pill {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background: var(--input-bg);
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            user-select: none;
            -webkit-user-select: none;
        }
        .day-pill:active {
            transform: scale(0.9);
        }
        .day-pill.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .task-time {
            font-size: 12px;
            color: var(--text-tertiary);
        }

        .settings-button {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 14px;
            text-decoration: underline;
        }

        .backup-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .backup-section button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 500;
        }

        .backup-export {
            background: #51cf66;
            color: white;
        }

        .backup-import {
            background: #667eea;
            color: white;
        }

        .backup-import input[type="file"] {
            display: none;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background: var(--input-bg);
            border-radius: 12px;
        }

        .toggle-switch label {
            color: var(--text-primary);
            font-size: 14px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .calendar-container {
            margin-top: 20px;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .calendar-nav {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
        }

        .calendar-month {
            font-size: 18px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
        }

        .calendar-day-header {
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            color: var(--text-secondary);
            padding: 8px 0;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .calendar-day:hover:not(.empty):not(.future) {
            transform: scale(1.05);
        }

        .calendar-day.empty {
            background: transparent;
            cursor: default;
        }

        .calendar-day.future, .calendar-day.no-tasks {
            background: var(--input-bg);
            color: var(--text-tertiary);
        }

        .calendar-day.today {
            background: var(--input-bg);
            color: var(--text-primary);
            border: 2px solid #667eea;
        }

        .calendar-day.green {
            background: #51cf66;
            color: white;
        }

        .calendar-day.yellow {
            background: #ffd43b;
            color: #333;
        }

        .calendar-day.orange {
            background: #ff922b;
            color: white;
        }

        .calendar-day.red {
            background: #ff6b6b;
            color: white;
        }

        .day-of-week {
            text-align: center;
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .day-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-bg);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            display: none;
            z-index: 1000;
            max-width: 300px;
            width: 90%;
            text-align: center;
        }

        .day-popup.show {
            display: block;
        }

        .day-popup h3 {
            margin-bottom: 15px;
            color: var(--text-primary);
            font-size: 18px;
        }

        .day-popup p {
            color: var(--text-secondary);
            margin-bottom: 20px;
            font-size: 16px;
        }

        .day-popup button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 500;
        }

        .achievement-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-bg);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            display: none;
            z-index: 1000;
            max-width: 300px;
            width: 90%;
            text-align: center;
        }

        .achievement-popup.show {
            display: block;
        }

        .achievement-popup .achievement-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .achievement-popup h3 {
            margin-bottom: 15px;
            color: var(--text-primary);
            font-size: 18px;
        }

        .achievement-popup p {
            color: var(--text-secondary);
            margin-bottom: 20px;
            font-size: 14px;
        }

        .achievement-popup button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="user-stats">
                <div class="level-info">
                    <div class="level-badge" id="levelBadge">1</div>
                    <div class="level-details">
                        <h2 id="levelTitle">Beginner</h2>
                        <p id="xpProgress">0 / 100 XP</p>
                    </div>
                </div>
                <div class="points">
                    <div class="points-value" id="totalGreenDays" style="color: #51cf66;">0</div>
                    <div class="points-label">Perfect Days</div>
                </div>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <div class="streak-info">
                <div class="streak-item">
                    <div class="streak-number" id="currentStreak">0</div>
                    <div class="streak-label">Current Streak</div>
                </div>
                <div class="streak-item">
                    <div class="streak-number" id="completedToday">0/0</div>
                    <div class="streak-label">Done Today</div>
                </div>
                <div class="streak-item">
                    <div class="streak-number" id="bestStreak">0</div>
                    <div class="streak-label">Best Streak</div>
                </div>
            </div>
            <button onclick="shareStreakProgress()" style="width: 100%; margin-top: 12px; padding: 10px; background: #51cf66; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px; letter-spacing: -0.2px; transition: all 0.2s ease;">üì§ Share Streak</button>
        </div>

        <div id="scheduleTab" class="tab-content active">
            <div class="section">
                <div class="section-title">
                    Schedule
                    <button class="add-button" onclick="toggleAddTask()">+ Add</button>
                </div>
                <div class="day-of-week" id="dayOfWeek"></div>
                <div id="noTimeTasks"></div>
                <div class="timeline-wrapper">
                    <div class="timeline" id="taskTimeline"></div>
                </div>
            </div>
        </div>

        <div id="achievementsTab" class="tab-content">
            <div class="section">
                <div class="section-title">Your Achievements</div>
                <div class="achievements" id="achievementsList"></div>
            </div>
        </div>

        <div id="calendarTab" class="tab-content">
            <div class="section">
                <div class="section-title">
                    Calendar
                    <button class="add-button" onclick="shareMonthlyProgress()" style="background: #51cf66;">üì§ Share</button>
                </div>
                <div class="calendar-container">
                    <div class="calendar-header">
                        <button class="calendar-nav" onclick="changeMonth(-1)">‚Üê</button>
                        <div class="calendar-month" id="calendarMonth"></div>
                        <button class="calendar-nav" onclick="changeMonth(1)">‚Üí</button>
                    </div>
                    <div id="calendarGrid" class="calendar-grid">
                        <!-- Calendar will be rendered here -->
                    </div>
                </div>
            </div>
        </div>

        <div id="settingsTab" class="tab-content">
            <div class="section">
                <div class="section-title">Settings</div>
                
                <div class="toggle-switch">
                    <label>Dark Mode</label>
                    <label class="switch">
                        <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()">
                        <span class="slider"></span>
                    </label>
                </div>

                <div style="margin-bottom: 20px;">
                    <h4 style="margin-bottom: 4px; color: var(--text-primary);">Schedule View</h4>
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 0;">How tasks are displayed on the Schedule tab</p>
                    <div class="view-selector" id="viewSelector">
                        <button class="view-sel-btn" data-view="list" onclick="setScheduleView('list')">
                            <span class="sel-icon">‚ò∞</span>List
                        </button>
                        <button class="view-sel-btn active" data-view="timeline" onclick="setScheduleView('timeline')">
                            <span class="sel-icon">‚óé</span>Timeline
                        </button>
                        <button class="view-sel-btn" data-view="grid" onclick="setScheduleView('grid')">
                            <span class="sel-icon">‚äû</span>Grid
                        </button>
                    </div>
                </div>

                <div style="margin-bottom: 20px;">
                    <h4 style="margin-bottom: 10px; color: var(--text-primary);">Notifications</h4>
                    <button class="add-button" id="notificationToggleBtn" onclick="requestNotificationPermission()">üîî Enable Notifications</button>
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;" id="notificationStatus">Notifications disabled</p>
                </div>

                <div class="backup-section">
                    <h4 style="margin-bottom: 15px; color: var(--text-primary);">Backup & Restore</h4>
                    <button class="backup-export" onclick="exportData()">üì• Export My Data</button>
                    <button class="backup-import" onclick="document.getElementById('importFile').click()">
                        üì§ Import Data
                    </button>
                    <input type="file" id="importFile" accept=".json" onchange="importData(event)" />
                    <button onclick="clearAllData()" style="width: 100%; padding: 12px; margin-top: 10px; background: #ff6b6b; color: white; border: none; border-radius: 12px; cursor: pointer; font-weight: 500;">üóëÔ∏è Clear All Data</button>
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 10px;">
                        Export your data before updating the app to keep your progress!
                    </p>
                </div>
            </div>
        </div>
    </div>

    <div class="bottom-nav">
        <div class="nav-item active" onclick="switchTab('schedule')">
            <div class="nav-icon">‚úì</div>
            <div>Schedule</div>
        </div>
        <div class="nav-item" onclick="switchTab('calendar')">
            <div class="nav-icon">üìÖ</div>
            <div>Calendar</div>
        </div>
        <div class="nav-item" onclick="switchTab('achievements')">
            <div class="nav-icon">üèÜ</div>
            <div>Achievements</div>
        </div>
        <div class="nav-item" onclick="switchTab('settings')">
            <div class="nav-icon">‚öôÔ∏è</div>
            <div>Settings</div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>
    <div class="celebration" id="celebration">
        <div class="celebration-icon" id="celebrationIcon">üéâ</div>
        <h3 id="celebrationTitle">Great Job!</h3>
        <p id="celebrationMessage">You earned 10 points!</p>
        <button onclick="closeCelebration()">Awesome!</button>
    </div>

    <div class="modal" id="taskModal">
        <h3>Add Task</h3>
        <div class="name-row">
            <div class="form-group">
                <label>Task Name</label>
                <input type="text" id="modalTaskName" placeholder="What do you need to do?" style="width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 12px; background: var(--input-bg); color: var(--text-primary); font-size: 16px;" />
            </div>
            <button class="icon-trigger" id="modalIconTrigger" onclick="openIconPopup('modal')">‚≠ê</button>
        </div>

        <div class="checkbox-group">
            <input type="checkbox" id="modalRecurring" onchange="toggleDaySelector('modal')" />
            <label for="modalRecurring">Repeat daily</label>
        </div>
        <div class="day-selector visible" id="modalDaySelector">
            <div class="day-pill active" data-day="1" onclick="toggleDayPill(this, 'modal')">Mo</div>
            <div class="day-pill active" data-day="2" onclick="toggleDayPill(this, 'modal')">Tu</div>
            <div class="day-pill active" data-day="3" onclick="toggleDayPill(this, 'modal')">We</div>
            <div class="day-pill active" data-day="4" onclick="toggleDayPill(this, 'modal')">Th</div>
            <div class="day-pill active" data-day="5" onclick="toggleDayPill(this, 'modal')">Fr</div>
            <div class="day-pill active" data-day="6" onclick="toggleDayPill(this, 'modal')">Sa</div>
            <div class="day-pill active" data-day="0" onclick="toggleDayPill(this, 'modal')">Su</div>
        </div>
        
        <div class="form-group">
            <label>Task Start Time (optional)</label>
            <input type="time" id="modalTime" style="width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 12px; background: var(--input-bg); color: var(--text-primary); font-size: 16px;" />
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="modalNotification" />
            <label for="modalNotification">Notify me at start time</label>
        </div>
        
        <div class="modal-buttons">
            <button class="btn-secondary" onclick="closeTaskModal()">Cancel</button>
            <button class="btn-primary" onclick="saveTask()">Add Task</button>
        </div>
    </div>

    <div class="modal" id="editTaskModal">
        <h3>Edit Task</h3>
        <div class="name-row">
            <div class="form-group">
                <label>Task Name</label>
                <input type="text" id="editTaskName" placeholder="What do you need to do?" style="width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 12px; background: var(--input-bg); color: var(--text-primary); font-size: 16px;" />
            </div>
            <button class="icon-trigger" id="editIconTrigger" onclick="openIconPopup('edit')">‚≠ê</button>
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="editRecurring" onchange="toggleDaySelector('edit')" />
            <label for="editRecurring">Repeat daily</label>
        </div>
        <div class="day-selector" id="editDaySelector">
            <div class="day-pill active" data-day="1" onclick="toggleDayPill(this, 'edit')">Mo</div>
            <div class="day-pill active" data-day="2" onclick="toggleDayPill(this, 'edit')">Tu</div>
            <div class="day-pill active" data-day="3" onclick="toggleDayPill(this, 'edit')">We</div>
            <div class="day-pill active" data-day="4" onclick="toggleDayPill(this, 'edit')">Th</div>
            <div class="day-pill active" data-day="5" onclick="toggleDayPill(this, 'edit')">Fr</div>
            <div class="day-pill active" data-day="6" onclick="toggleDayPill(this, 'edit')">Sa</div>
            <div class="day-pill active" data-day="0" onclick="toggleDayPill(this, 'edit')">Su</div>
        </div>
        
        <div class="form-group">
            <label>Task Start Time (optional)</label>
            <input type="time" id="editTime" style="width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 12px; background: var(--input-bg); color: var(--text-primary); font-size: 16px;" />
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="editNotification" />
            <label for="editNotification">Notify me at start time</label>
        </div>
        
        <div class="modal-buttons">
            <button class="btn-secondary" onclick="closeEditTaskModal()">Cancel</button>
            <button class="btn-primary" onclick="updateTask()">Save Changes</button>
        </div>
        
        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
            <button onclick="deleteTaskFromModal()" style="width: 100%; padding: 12px; background: #ff6b6b; color: white; border: none; border-radius: 12px; cursor: pointer; font-weight: 500;">Delete Task</button>
        </div>
    </div>

    <div class="modal" id="deleteConfirmModal">
        <h3>Delete Task?</h3>
        <p style="color: var(--text-secondary); margin-bottom: 20px;">Are you sure you want to delete this task? This cannot be undone.</p>
        <div class="modal-buttons">
            <button class="btn-secondary" onclick="cancelDelete()">Cancel</button>
            <button class="btn-primary" style="background: #ff6b6b;" onclick="confirmDelete()">Delete</button>
        </div>
    </div>

    <!-- Icon picker popup sheet -->
    <div class="icon-popup-overlay" id="iconPopupOverlay" onclick="closeIconPopup()"></div>
    <div class="icon-popup" id="iconPopup">
        <div class="icon-popup-handle"></div>
        <div class="icon-popup-grid" id="iconPopupGrid"></div>
    </div>

    <div class="day-popup" id="dayPopup">
        <h3 id="dayPopupDate"></h3>
        <p id="dayPopupStats"></p>
        <button onclick="closeDayPopup()">Close</button>
    </div>

    <div class="achievement-popup" id="achievementPopup">
        <div class="achievement-icon" id="achievementPopupIcon"></div>
        <h3 id="achievementPopupName"></h3>
        <p id="achievementPopupDescription"></p>
        <button onclick="closeAchievementPopup()">Close</button>
    </div>

    <script>
        // Game State
        let gameState = {
            level: 1,
            xp: 0,
            totalPoints: 0,
            currentStreak: 0,
            bestStreak: 0,
            lastCheckIn: null,
            tasks: [],
            completedToday: 0,
            totalCompleted: 0,
            achievements: [],
            notificationsEnabled: false,
            scheduledNotifications: [], // Array of {taskId, scheduledFor} for persistence across refreshes
            dailyHistory: {}, // { 'YYYY-MM-DD': { completed: X, total: Y, rating: 'green'/'yellow'/'orange'/'red'/'none' } }
            darkMode: false,
            scheduleView: 'timeline',
            currentCalendarMonth: new Date().getMonth(),
            currentCalendarYear: new Date().getFullYear()
        };

        let currentEditingTaskId = null;

        // Achievements Definition
        const achievementDefs = [
            { 
                id: 'first_steps', 
                name: 'First Steps', 
                icon: 'üéØ', 
                description: 'Avoid getting a red or orange day for 3 days in a row',
                condition: () => checkConsecutiveGoodDays(3)
            },
            { 
                id: 'level_10', 
                name: 'Level 10', 
                icon: 'üíé', 
                description: 'Reach level 10',
                condition: () => gameState.level >= 10 
            },
            { 
                id: 'level_25', 
                name: 'Level 25', 
                icon: 'üåü', 
                description: 'Reach level 25',
                condition: () => gameState.level >= 25 
            },
            { 
                id: 'level_50', 
                name: 'Level 50', 
                icon: '‚≠ê', 
                description: 'Reach level 50',
                condition: () => gameState.level >= 50 
            },
            { 
                id: 'greener_grass', 
                name: 'Greener Grass', 
                icon: 'üå±', 
                description: 'Get green days (finish all tasks) 10 days in a row',
                condition: () => checkConsecutivePerfectDays(10)
            },
            { 
                id: 'locked_in', 
                name: 'Locked In', 
                icon: 'üîí', 
                description: 'Finish all tasks every day for a whole calendar month',
                condition: () => checkFullMonthPerfect()
            },
            { 
                id: 'super_streaker', 
                name: 'Super Streaker', 
                icon: 'üî•', 
                description: 'Reach a streak of 100 good days',
                condition: () => gameState.bestStreak >= 100 
            },
            { 
                id: 'salvation', 
                name: 'Salvation', 
                icon: 'üëë', 
                description: 'Reach level 100',
                condition: () => gameState.level >= 100 
            }
        ];

        // Per-level cost: XP required to go from level L to L+1
        function perLevelCost(level) {
            // Levels 1-20: linear ramp 105 ‚Üí 200
            if (level <= 20) return 100 + (5 * level);

            // Levels 21-100: linearly interpolate between milestone anchors
            // Anchors: 21‚Üí200, 30‚Üí211, 40‚Üí244, 50‚Üí299, 60‚Üí376, 70‚Üí475, 80‚Üí596, 90‚Üí749, 100‚Üí904
            if (level <= 100) {
                const milestones = [21, 30, 40, 50, 60, 70, 80, 90, 100];
                const costs      = [200, 211, 244, 299, 376, 475, 596, 749, 904];
                let lower = 0;
                for (let i = 0; i < milestones.length - 1; i++) {
                    if (level >= milestones[i] && level <= milestones[i + 1]) {
                        lower = i; break;
                    }
                }
                const t = (level - milestones[lower]) / (milestones[lower + 1] - milestones[lower]);
                return Math.round(costs[lower] + t * (costs[lower + 1] - costs[lower]));
            }

            // Levels 101+: continue increasing by the same delta as 99‚Üí100 (which is 15 per level)
            return 904 + 15 * (level - 100);
        }

        // Cumulative XP threshold to reach a given level (cached for performance)
        const _levelThresholdCache = [0, 0]; // index 0 unused; level 1 = 0 XP
        function getLevelThreshold(level) {
            if (level <= 1) return 0;
            // Fill cache up to the requested level if needed
            while (_levelThresholdCache.length <= level) {
                const prev = _levelThresholdCache.length - 1;
                _levelThresholdCache.push(_levelThresholdCache[prev] + perLevelCost(prev));
            }
            return _levelThresholdCache[level];
        }

        function getLevelTitle(level) {
            if (level >= 100) return 'Hero';
            if (level >= 90) return 'Legend';
            if (level >= 80) return 'Champion';
            if (level >= 70) return 'Virtuoso';
            if (level >= 60) return 'Master';
            if (level >= 50) return 'Expert';
            if (level >= 40) return 'Professional';
            if (level >= 30) return 'Adept';
            if (level >= 20) return 'Journeyman';
            if (level >= 10) return 'Apprentice';
            if (level >= 5) return 'Novice';
            return 'Beginner';
        }

        // Initialize
        async function init() {
            await loadGameState();
            // Always open calendar to current month, not the saved month
            gameState.currentCalendarMonth = new Date().getMonth();
            gameState.currentCalendarYear = new Date().getFullYear();
            applyDarkMode();
            // sync view selector to saved preference
            document.querySelectorAll('.view-sel-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === (gameState.scheduleView || 'timeline'));
            });
            checkStreak();
            checkNotificationPermission();
            scheduleAllNotifications();
            startDailyCheckSystem();
            renderAll();
        }

        // Storage functions
        async function loadGameState() {
            try {
                const saved = localStorage.getItem('scheduleBuddyGameState');
                if (saved) {
                    gameState = JSON.parse(saved);
                }
            } catch (e) {
                // start fresh
            }
        }

        async function saveGameState() {
            try {
                localStorage.setItem('scheduleBuddyGameState', JSON.stringify(gameState));
            } catch (e) {
                console.error('Failed to save:', e);
            }
        }

        // Check and update streak
        function checkStreak() {
            const today = new Date().toDateString();
            const todayKey = formatDateKey(new Date());
            const yesterday = new Date(Date.now() - 86400000);
            const yesterdayKey = formatDateKey(yesterday);
            
            if (gameState.lastCheckIn !== today) {
                // Save yesterday's rating before resetting
                if (gameState.lastCheckIn) {
                    const lastDate = new Date(gameState.lastCheckIn);
                    const lastKey = formatDateKey(lastDate);
                    saveDayRating(lastKey);
                }
                
                // Calculate new streak
                const yesterdayRating = gameState.dailyHistory[yesterdayKey]?.rating;
                if (yesterdayRating === 'green' || yesterdayRating === 'yellow') {
                    gameState.currentStreak++;
                } else if (gameState.lastCheckIn !== null) {
                    gameState.currentStreak = 0;
                }
                
                gameState.bestStreak = Math.max(gameState.bestStreak, gameState.currentStreak);
                gameState.lastCheckIn = today;
                gameState.completedToday = 0;
                
                // Reset recurring tasks, remove non-recurring completed tasks
                gameState.tasks = gameState.tasks.map(task => {
                    if (task.recurring && task.completed) {
                        return { ...task, completed: false };
                    }
                    return task;
                }).filter(task => task.recurring || !task.completed);
                
                saveGameState();
            }
        }

        function formatDateKey(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function saveDayRating(dateKey) {
            const recurringTasks = gameState.tasks.filter(t => t.recurring && isTaskActiveToday(t));
            const totalTasks = recurringTasks.length;
            
            if (totalTasks === 0) {
                gameState.dailyHistory[dateKey] = { completed: 0, total: 0, rating: 'none' };
                return;
            }
            
            const completedTasks = gameState.completedToday;
            const percentage = completedTasks / totalTasks;
            
            let rating;
            if (percentage === 1) rating = 'green';
            else if (percentage >= 0.75) rating = 'yellow';
            else if (percentage >= 0.5) rating = 'orange';
            else rating = 'red';
            
            gameState.dailyHistory[dateKey] = { completed: completedTasks, total: totalTasks, rating };
        }

        // Task Management
        function toggleAddTask() {
            document.getElementById('taskModal').classList.add('show');
            document.getElementById('overlay').classList.add('show');
            document.getElementById('modalTaskName').focus();
            // reset icon trigger to default
            const trigger = document.getElementById('modalIconTrigger');
            trigger.textContent = '‚≠ê';
            trigger.dataset.iconId = '';
        }

        function toggleDaySelector(prefix) {
            const checkbox = document.getElementById(prefix === 'modal' ? 'modalRecurring' : 'editRecurring');
            const selector = document.getElementById(prefix === 'modal' ? 'modalDaySelector' : 'editDaySelector');
            selector.classList.toggle('visible', checkbox.checked);
        }

        function toggleDayPill(pill, prefix) {
            // Don't allow deselecting the last active pill
            const selector = document.getElementById(prefix === 'modal' ? 'modalDaySelector' : 'editDaySelector');
            const activePills = selector.querySelectorAll('.day-pill.active');
            if (activePills.length === 1 && pill.classList.contains('active')) return;
            pill.classList.toggle('active');
        }

        function getSelectedDays(prefix) {
            const selector = document.getElementById(prefix === 'modal' ? 'modalDaySelector' : 'editDaySelector');
            return Array.from(selector.querySelectorAll('.day-pill.active')).map(p => parseInt(p.dataset.day));
        }

        function setDayPills(prefix, days) {
            const selector = document.getElementById(prefix === 'modal' ? 'modalDaySelector' : 'editDaySelector');
            selector.querySelectorAll('.day-pill').forEach(pill => {
                pill.classList.toggle('active', days.includes(parseInt(pill.dataset.day)));
            });
        }

        function resetDayPills(prefix) {
            setDayPills(prefix, [0, 1, 2, 3, 4, 5, 6]);
        }

        function isTaskActiveToday(task) {
            if (!task.recurring) return true;
            if (!task.days || task.days.length === 0) return true;
            return task.days.includes(new Date().getDay());
        }

        function closeTaskModal() {
            document.getElementById('taskModal').classList.remove('show');
            document.getElementById('overlay').classList.remove('show');
            document.getElementById('modalTaskName').value = '';
            document.getElementById('modalRecurring').checked = true;
            document.getElementById('modalDaySelector').classList.add('visible');
            resetDayPills('modal');
            document.getElementById('modalNotification').checked = false;
            document.getElementById('modalTime').value = '';
        }

        function saveTask() {
            const taskName = document.getElementById('modalTaskName').value.trim();
            const recurring = document.getElementById('modalRecurring').checked;
            const notification = document.getElementById('modalNotification').checked;
            const time = document.getElementById('modalTime').value;
            
            if (!taskName) return;
            
            if (notification && !time) {
                alert('Please set a start time to enable notifications');
                return;
            }
            
            const task = {
                id: Date.now(),
                name: taskName,
                completed: false,
                recurring: recurring,
                days: recurring ? getSelectedDays('modal') : [0,1,2,3,4,5,6],
                notification: notification,
                time: time || null,
                icon: getIconFromTrigger('modal')
            };
            
            gameState.tasks.push(task);
            
            if (notification && time) {
                scheduleNotification(task);
            }
            
            closeTaskModal();
            saveGameState();
            renderTasks();
        }

        function openEditTaskModal(taskId) {
            const task = gameState.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            currentEditingTaskId = taskId;
            
            document.getElementById('editTaskName').value = task.name;
            document.getElementById('editRecurring').checked = task.recurring || false;
            document.getElementById('editDaySelector').classList.toggle('visible', task.recurring || false);
            setDayPills('edit', task.days || [0,1,2,3,4,5,6]);
            document.getElementById('editNotification').checked = task.notification || false;
            document.getElementById('editTime').value = task.time || '';
            // set icon trigger
            const editTrigger = document.getElementById('editIconTrigger');
            if (task.icon && ICON_LIBRARY[task.icon]) {
                editTrigger.textContent = ICON_LIBRARY[task.icon].emoji;
                editTrigger.dataset.iconId = task.icon;
            } else {
                editTrigger.textContent = '‚≠ê';
                editTrigger.dataset.iconId = '';
            }
            
            document.getElementById('editTaskModal').classList.add('show');
            document.getElementById('overlay').classList.add('show');
        }

        function closeEditTaskModal() {
            document.getElementById('editTaskModal').classList.remove('show');
            document.getElementById('overlay').classList.remove('show');
            currentEditingTaskId = null;
        }

        function updateTask() {
            if (currentEditingTaskId === null) return;
            
            const task = gameState.tasks.find(t => t.id === currentEditingTaskId);
            if (!task) return;
            
            const taskName = document.getElementById('editTaskName').value.trim();
            const recurring = document.getElementById('editRecurring').checked;
            const notification = document.getElementById('editNotification').checked;
            const time = document.getElementById('editTime').value;
            
            if (!taskName) return;
            
            if (notification && !time) {
                alert('Please set a start time to enable notifications');
                return;
            }
            
            // Update task properties
            task.name = taskName;
            task.recurring = recurring;
            task.days = recurring ? getSelectedDays('edit') : [0,1,2,3,4,5,6];
            task.notification = notification;
            task.time = time || null;
            task.icon = getIconFromTrigger('edit');
            
            // Reschedule notifications if needed
            if (notification && time) {
                scheduleNotification(task);
            }
            
            closeEditTaskModal();
            saveGameState();
            renderTasks();
        }

        function deleteTaskFromModal() {
            if (currentEditingTaskId === null) return;
            
            const taskToDelete = gameState.tasks.find(t => t.id === currentEditingTaskId);
            if (!taskToDelete) return;
            
            // Hide edit modal but keep overlay visible
            document.getElementById('editTaskModal').classList.remove('show');
            // Show custom confirmation modal
            document.getElementById('deleteConfirmModal').classList.add('show');
        }

        function closeDeleteConfirm() {
            document.getElementById('deleteConfirmModal').classList.remove('show');
            document.getElementById('overlay').classList.remove('show');
        }

        function cancelDelete() {
            document.getElementById('deleteConfirmModal').classList.remove('show');
            // Go back to edit modal (keep overlay visible)
            document.getElementById('editTaskModal').classList.add('show');
        }

        function confirmDelete() {
            closeDeleteConfirm();
            deleteTask(currentEditingTaskId);
            closeEditTaskModal();
        }

        function getTaskXP() {
            const recurringCount = gameState.tasks.filter(t => t.recurring).length;
            if (recurringCount <= 3) return 45;
            if (recurringCount <= 6) return 25;
            if (recurringCount <= 8) return 17;
            if (recurringCount <= 10) return 13;
            return 10;
        }

        function toggleTask(taskId) {
            const task = gameState.tasks.find(t => t.id === taskId);
            if (task && !task.completed) {
                task.completed = true;
                gameState.completedToday++;
                gameState.totalCompleted++;
                const xp = getTaskXP();
                addXP(xp);
                checkAchievements();
                showCelebration('Task Complete! üéØ', `+${xp} XP`);
                
                // Update today's calendar color in real-time
                const todayKey = formatDateKey(new Date());
                saveDayRating(todayKey);
                
                saveGameState();
                renderHeader();
                renderTasks();
            }
        }

        function deleteTask(taskId) {
            gameState.tasks = gameState.tasks.filter(t => t.id !== taskId);
            saveGameState();
            renderAll();
        }

        // XP and Leveling
        function addXP(points) {
            const oldLevel = gameState.level;
            gameState.xp += points;
            gameState.totalPoints += points;
            
            // Check for level up
            let threshold = getLevelThreshold(gameState.level + 1);
            while (gameState.xp >= threshold) {
                levelUp();
                threshold = getLevelThreshold(gameState.level + 1);
            }
            
            // Prevent level down - keep XP at minimum for current level
            // The minimum XP for a level is the threshold of the previous level
            const minXPForLevel = gameState.level > 1 ? getLevelThreshold(gameState.level) : 0;
            if (gameState.xp < minXPForLevel) {
                gameState.xp = minXPForLevel;
            }
        }

        function subtractXP(points) {
            gameState.xp -= points;
            
            // Prevent level down - keep XP at minimum for current level
            // The minimum XP for current level is the threshold to reach that level
            const minXPForLevel = getLevelThreshold(gameState.level);
            if (gameState.xp < minXPForLevel) {
                gameState.xp = minXPForLevel;
            }
        }

        function levelUp() {
            gameState.level++;
            showCelebration('Level Up! üéâ', `You reached Level ${gameState.level}!`, 'üåü');
            checkAchievements();
        }

        // Achievements
        function checkAchievements() {
            achievementDefs.forEach(def => {
                if (!gameState.achievements.includes(def.id) && def.condition()) {
                    gameState.achievements.push(def.id);
                    showCelebration('Achievement Unlocked! üèÜ', def.name, def.icon);
                }
            });
        }

        // UI Rendering
        function renderAll() {
            renderHeader();
            renderTasks();
            renderAchievements();
            renderCalendar();
        }

        function renderHeader() {
            const currentThreshold = getLevelThreshold(gameState.level);
            const nextThreshold = getLevelThreshold(gameState.level + 1);
            const progress = ((gameState.xp - currentThreshold) / (nextThreshold - currentThreshold)) * 100;
            
            document.getElementById('levelBadge').textContent = gameState.level;
            document.getElementById('levelTitle').textContent = getLevelTitle(gameState.level);
            document.getElementById('xpProgress').textContent = `${gameState.xp} / ${nextThreshold} XP`;
            document.getElementById('progressFill').style.width = `${Math.min(progress, 100)}%`;
            
            // Calculate total green days
            const greenDays = Object.values(gameState.dailyHistory).filter(day => day.rating === 'green').length;
            document.getElementById('totalGreenDays').textContent = greenDays;
            
            document.getElementById('currentStreak').textContent = gameState.currentStreak;
            document.getElementById('bestStreak').textContent = gameState.bestStreak;
            
            // Update Done Today with x/y format
            const totalToday = gameState.tasks.filter(t => isTaskActiveToday(t)).length;
            document.getElementById('completedToday').textContent = `${gameState.completedToday}/${totalToday}`;
        }

        // ‚îÄ‚îÄ Icon library ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const ICON_LIBRARY = {
            meal:      { label: 'Meal',      emoji: 'üçΩÔ∏è' },
            coffee:    { label: 'Coffee',    emoji: '‚òï' },
            water:     { label: 'Water',     emoji: 'üíß' },
            exercise:  { label: 'Exercise',  emoji: 'üèãÔ∏è' },
            walk:      { label: 'Walk',      emoji: 'üö∂' },
            stretch:   { label: 'Stretch',   emoji: 'üßò' },
            meditate:  { label: 'Meditate',  emoji: 'üß†' },
            study:     { label: 'Study',     emoji: 'üìö' },
            work:      { label: 'Work',      emoji: 'üíº' },
            journal:   { label: 'Journal',   emoji: '‚úèÔ∏è' },
            hygiene:   { label: 'Hygiene',   emoji: 'ü™•' },
            shower:    { label: 'Shower',    emoji: 'üöø' },
            chores:    { label: 'Chores',    emoji: 'üßπ' },
            pet:       { label: 'Pet',       emoji: 'üêæ' },
            morning:   { label: 'Morning',   emoji: 'üåÖ' },
            evening:   { label: 'Evening',   emoji: 'üåô' },
            sleep:     { label: 'Sleep',     emoji: 'üò¥' },
            meds:      { label: 'Meds',      emoji: 'üíä' },
            skincare:  { label: 'Skincare',  emoji: 'üß¥' },
            music:     { label: 'Music',     emoji: 'üéµ' },
            read:      { label: 'Read',      emoji: 'üìñ' },
            phone:     { label: 'Phone',     emoji: 'üì±' },
            cook:      { label: 'Cook',      emoji: 'üç≥' },
            clean:     { label: 'Clean',     emoji: '‚ú®' },
        };

        function getPillIcon(task) {
            if (task.icon && ICON_LIBRARY[task.icon]) return ICON_LIBRARY[task.icon].emoji;
            return task.recurring ? 'üîÑ' : '‚≠ê';
        }

        // ‚îÄ‚îÄ Icon popup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let iconPopupSource = null; // 'modal' or 'edit'
        let iconPopupSelected = null;

        function openIconPopup(source) {
            iconPopupSource = source;
            // read current selection from the trigger button's data
            const trigger = document.getElementById(source + 'IconTrigger');
            iconPopupSelected = trigger.dataset.iconId || null;

            // build grid
            const grid = document.getElementById('iconPopupGrid');
            let html = `<button class="icon-popup-btn clear-btn ${iconPopupSelected === null ? 'selected' : ''}"
                            data-icon-id=""
                            onclick="iconPopupPick('')"
                            title="No icon">‚úï</button>`;
            html += Object.entries(ICON_LIBRARY).map(([id, { label, emoji }]) =>
                `<button class="icon-popup-btn ${iconPopupSelected === id ? 'selected' : ''}"
                         data-icon-id="${id}"
                         onclick="iconPopupPick('${id}')"
                         title="${label}">${emoji}</button>`
            ).join('');
            grid.innerHTML = html;

            document.getElementById('iconPopupOverlay').classList.add('show');
            document.getElementById('iconPopup').classList.add('show');
        }

        function iconPopupPick(id) {
            iconPopupSelected = id || null;

            // update highlight
            document.querySelectorAll('.icon-popup-btn').forEach(btn => {
                btn.classList.toggle('selected',
                    id === '' ? btn.dataset.iconId === '' : btn.dataset.iconId === id);
            });

            // update the trigger button
            const trigger = document.getElementById(iconPopupSource + 'IconTrigger');
            if (id && ICON_LIBRARY[id]) {
                trigger.textContent = ICON_LIBRARY[id].emoji;
                trigger.dataset.iconId = id;
            } else {
                trigger.textContent = '‚≠ê';
                trigger.dataset.iconId = '';
            }

            closeIconPopup();
        }

        function closeIconPopup() {
            document.getElementById('iconPopupOverlay').classList.remove('show');
            document.getElementById('iconPopup').classList.remove('show');
            iconPopupSource = null;
        }

        function getIconFromTrigger(source) {
            const trigger = document.getElementById(source + 'IconTrigger');
            return trigger.dataset.iconId || null;
        }

        function setScheduleView(view) {
            gameState.scheduleView = view;
            // update selector highlight
            document.querySelectorAll('.view-sel-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });
            saveGameState();
            renderTasks();
        }

        function renderTasks() {
            const noTimeContainer = document.getElementById('noTimeTasks');
            const timeline = document.getElementById('taskTimeline');
            const dayOfWeekEl = document.getElementById('dayOfWeek');
            
            const today = new Date();
            dayOfWeekEl.textContent = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'][today.getDay()];
            
            if (gameState.tasks.length === 0) {
                noTimeContainer.innerHTML = '';
                timeline.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìù</div>
                        <div>No tasks yet. Add one to get started!</div>
                    </div>
                `;
                return;
            }

            const todayTasks = gameState.tasks.filter(task => isTaskActiveToday(task));
            if (todayTasks.length === 0) {
                noTimeContainer.innerHTML = '';
                timeline.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üò¥</div>
                        <div>Rest day! No tasks scheduled for today.</div>
                    </div>
                `;
                return;
            }

            const withTime    = todayTasks.filter(t => t.time).sort((a, b) => a.time.localeCompare(b.time));
            const withoutTime = todayTasks.filter(t => !t.time);
            const allSorted   = [...withTime, ...withoutTime]; // for list & grid: time tasks first, then no-time
            const xpPerTask   = getTaskXP(); // same for every task this render ‚Äî cache once

            // shared helpers
            function fmtShort(timeStr) {
                const [h, m] = timeStr.split(':').map(Number);
                const ampm = h >= 12 ? 'PM' : 'AM';
                const h12  = h % 12 || 12;
                return m === 0 ? `${h12} ${ampm}` : `${h12}:${m.toString().padStart(2,'0')} ${ampm}`;
            }

            // blue once the time has passed, gray while it's still upcoming
            function timeColor(timeStr) {
                const now = new Date();
                const [h, m] = timeStr.split(':').map(Number);
                const taskMinutes = h * 60 + m;
                const nowMinutes  = now.getHours() * 60 + now.getMinutes();
                return taskMinutes <= nowMinutes ? '#667eea' : 'var(--text-tertiary)';
            }

            const checkSVG = `<svg width="11" height="11" viewBox="0 0 12 12" fill="none"><polyline points="2,6 5,9 10,3" stroke="#fff" stroke-width="2.3" stroke-linecap="round" stroke-linejoin="round"/></svg>`;

            // ‚îÄ‚îÄ Long-press to edit ‚îÄ‚îÄ
            function attachLongPress(el, taskId) {
                let pressTimer;
                const ignore = (e) => e.target.closest('.timeline-circle') || e.target.closest('.task-checkbox') || e.target.closest('.grid-card-circle');
                el.addEventListener('touchstart', (e) => {
                    if (ignore(e)) return;
                    pressTimer = setTimeout(() => openEditTaskModal(taskId), 500);
                });
                el.addEventListener('touchend',  () => clearTimeout(pressTimer));
                el.addEventListener('touchmove', () => clearTimeout(pressTimer));
                el.addEventListener('mousedown', (e) => {
                    if (ignore(e)) return;
                    pressTimer = setTimeout(() => openEditTaskModal(taskId), 500);
                });
                el.addEventListener('mouseup',   () => clearTimeout(pressTimer));
                el.addEventListener('mouseleave',() => clearTimeout(pressTimer));
            }

            const view = gameState.scheduleView || 'timeline';

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // LIST VIEW ‚Äî original single-column task-item rows
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if (view === 'list') {
                noTimeContainer.style.display = 'block';
                noTimeContainer.innerHTML = '';
                timeline.innerHTML = allSorted.map(task => `
                    <div class="task-item ${task.completed ? 'completed' : ''}" data-task-id="${task.id}">
                        <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''}
                               onchange="toggleTask(${task.id})" ${task.completed ? 'disabled' : ''}>
                        <div class="task-content">
                            <div class="task-name">
                                ${task.name}
                                ${task.recurring ? '<span class="task-recurring">Daily</span>' : ''}
                            </div>
                            <div class="task-points">
                                ${task.time ? `<span style="color:${timeColor(task.time)}">${fmtShort(task.time)} ¬∑ </span>` : ''}+${xpPerTask} XP
                            </div>
                        </div>
                    </div>
                `).join('');

                document.querySelectorAll('#taskTimeline .task-item').forEach(el => {
                    attachLongPress(el, parseInt(el.dataset.taskId));
                });
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // TIMELINE VIEW ‚Äî connected pill chain (default)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            else if (view === 'timeline') {
                noTimeContainer.style.display = 'block';

                // no-time tasks as floating pills (no time label, no connector lines)
                noTimeContainer.innerHTML = withoutTime.map(task => {
                    const isDone = task.completed;
                    const subParts = [`+${xpPerTask} XP`];
                    if (task.recurring) subParts.push('Daily');
                    return `
                    <div class="timeline-row ${isDone ? 'completed' : ''}" data-task-id="${task.id}" style="margin-bottom:6px">
                        <div class="timeline-connector-col">
                            <div class="timeline-pill ${isDone ? 'completed' : ''}">
                                <span class="timeline-pill-icon">${getPillIcon(task)}</span>
                            </div>
                        </div>
                        <div class="timeline-content-col">
                            <div class="timeline-content-left">
                                <span class="timeline-task-name">${task.name}</span>
                                <span class="timeline-task-sub">${subParts.join(' ‚Ä¢ ')}</span>
                            </div>
                            <div class="timeline-circle ${isDone ? 'completed' : ''}" onclick="toggleTask(${task.id})">
                                ${isDone ? checkSVG : ''}
                            </div>
                        </div>
                    </div>`;
                }).join('');

                // timed tasks as connected pills
                let rowsHTML = '';
                withTime.forEach((task, idx) => {
                    const isDone   = task.completed;
                    const startFmt = fmtShort(task.time);
                    const isFirst  = idx === 0;
                    const isLast   = idx === withTime.length - 1;

                    const subParts = [];
                    subParts.push(`+${xpPerTask} XP`);
                    if (task.recurring) subParts.push('Daily');

                    rowsHTML += `
                    <div class="timeline-row ${isDone ? 'completed' : ''}" data-task-id="${task.id}">
                        <div class="timeline-label-col">
                            <span class="timeline-label" style="color:${timeColor(task.time)}">${startFmt}</span>
                        </div>
                        <div class="timeline-connector-col">
                            ${isFirst ? '' : '<div class="timeline-line-seg"></div>'}
                            <div class="timeline-pill ${isDone ? 'completed' : ''}">
                                <span class="timeline-pill-icon">${getPillIcon(task)}</span>
                            </div>
                            ${isLast ? '' : '<div class="timeline-line-seg"></div>'}
                        </div>
                        <div class="timeline-content-col">
                            <div class="timeline-content-left">
                                <span class="timeline-task-name">${task.name}</span>
                                <span class="timeline-task-sub">${subParts.join(' ‚Ä¢ ')}</span>
                            </div>
                            <div class="timeline-circle ${isDone ? 'completed' : ''}" onclick="toggleTask(${task.id})">
                                ${isDone ? checkSVG : ''}
                            </div>
                        </div>
                    </div>`;
                });

                timeline.innerHTML = `<div class="timeline">${rowsHTML}</div>`;

                document.querySelectorAll('.timeline-row').forEach(el => {
                    attachLongPress(el, parseInt(el.dataset.taskId));
                });
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // GRID VIEW ‚Äî 2-column cards
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            else if (view === 'grid') {
                noTimeContainer.style.display = 'none';
                noTimeContainer.innerHTML = '';

                timeline.innerHTML = `<div class="grid-view">${allSorted.map(task => {
                    const isDone = task.completed;
                    // Daily + time as one group; XP is separate and bottom-anchored
                    const topMeta = [task.time ? `<span style="color:${timeColor(task.time)};font-weight:500">${fmtShort(task.time)}</span>` : '', task.recurring ? '<span class="task-recurring" style="margin-left:0">Daily</span>' : ''].filter(Boolean).join(' ');

                    return `
                    <div class="grid-card ${isDone ? 'completed' : ''}" data-task-id="${task.id}">
                        <div class="grid-card-top">
                            <span class="grid-card-icon">${getPillIcon(task)}</span>
                            <div class="grid-card-circle ${isDone ? 'completed' : ''}" onclick="toggleTask(${task.id})">
                                ${isDone ? checkSVG : ''}
                            </div>
                        </div>
                        <div class="grid-card-name">${task.name}</div>
                        ${topMeta ? `<div class="grid-card-meta">${topMeta}</div>` : ''}
                        <div class="grid-card-xp">+${xpPerTask} XP</div>
                    </div>`;
                }).join('')}</div>`;

                document.querySelectorAll('.grid-card').forEach(el => {
                    attachLongPress(el, parseInt(el.dataset.taskId));
                });
            }
        }

        function renderAchievements() {
            const list = document.getElementById('achievementsList');
            list.innerHTML = achievementDefs.map(def => `
                <div class="achievement ${gameState.achievements.includes(def.id) ? 'unlocked' : ''}" onclick="showAchievementPopup('${def.id}')">
                    <div class="achievement-icon">${def.icon}</div>
                    <div class="achievement-name">${def.name}</div>
                </div>
            `).join('');
        }

        function showAchievementPopup(achievementId) {
            const achievement = achievementDefs.find(a => a.id === achievementId);
            if (!achievement) return;
            
            document.getElementById('achievementPopupIcon').textContent = achievement.icon;
            document.getElementById('achievementPopupName').textContent = achievement.name;
            document.getElementById('achievementPopupDescription').textContent = achievement.description;
            
            document.getElementById('achievementPopup').classList.add('show');
            document.getElementById('overlay').classList.add('show');
        }

        function closeAchievementPopup() {
            document.getElementById('achievementPopup').classList.remove('show');
            document.getElementById('overlay').classList.remove('show');
        }

        function renderCalendar() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            
            const month = gameState.currentCalendarMonth;
            const year = gameState.currentCalendarYear;
            
            document.getElementById('calendarMonth').textContent = `${monthNames[month]} ${year}`;
            
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const today = new Date();
            const todayKey = formatDateKey(today);
            
            let calendarHTML = '';
            
            // Add day headers
            const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            dayHeaders.forEach(day => {
                calendarHTML += `<div class="calendar-day-header">${day}</div>`;
            });
            
            // Empty cells before the first day
            for (let i = 0; i < firstDay; i++) {
                calendarHTML += '<div class="calendar-day empty"></div>';
            }
            
            // Days of the month
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                const dateKey = formatDateKey(date);
                const dayData = gameState.dailyHistory[dateKey];
                
                let className = 'calendar-day';
                let onClick = '';
                
                if (dateKey === todayKey) {
                    className += ' today';
                } else if (date > today) {
                    className += ' future';
                } else if (!dayData || dayData.rating === 'none') {
                    className += ' no-tasks';
                } else {
                    className += ` ${dayData.rating}`;
                    onClick = `onclick="showDayPopup('${dateKey}')"`;
                }
                
                calendarHTML += `<div class="${className}" ${onClick}>${day}</div>`;
            }
            
            document.getElementById('calendarGrid').innerHTML = calendarHTML;
        }

        function showDayPopup(dateKey) {
            const dayData = gameState.dailyHistory[dateKey];
            if (!dayData || dayData.rating === 'none') return;
            
            const date = new Date(dateKey);
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            const dateStr = `${monthNames[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
            
            document.getElementById('dayPopupDate').textContent = dateStr;
            document.getElementById('dayPopupStats').textContent = 
                `Completed ${dayData.completed} out of ${dayData.total} tasks`;
            
            document.getElementById('dayPopup').classList.add('show');
            document.getElementById('overlay').classList.add('show');
        }

        function closeDayPopup() {
            document.getElementById('dayPopup').classList.remove('show');
            document.getElementById('overlay').classList.remove('show');
        }

        function changeMonth(direction) {
            gameState.currentCalendarMonth += direction;
            
            if (gameState.currentCalendarMonth > 11) {
                gameState.currentCalendarMonth = 0;
                gameState.currentCalendarYear++;
            } else if (gameState.currentCalendarMonth < 0) {
                gameState.currentCalendarMonth = 11;
                gameState.currentCalendarYear--;
            }
            
            renderCalendar();
            saveGameState();
        }

        // Navigation
        function switchTab(tab) {
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
            
            document.getElementById(`${tab}Tab`).classList.add('active');
            event.currentTarget.classList.add('active');
            
            if (tab === 'calendar') {
                renderCalendar();
            }
        }

        // Dark Mode
        function toggleDarkMode() {
            gameState.darkMode = !gameState.darkMode;
            applyDarkMode();
            saveGameState();
        }

        function applyDarkMode() {
            if (gameState.darkMode) {
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeToggle').checked = true;
            } else {
                document.body.classList.remove('dark-mode');
                document.getElementById('darkModeToggle').checked = false;
            }
        }

        // Daily Check System - Penalizes missed recurring tasks at midnight
        function startDailyCheckSystem() {
            // Check every minute if we've crossed midnight
            setInterval(() => {
                const now = new Date();
                const currentDay = now.toDateString();
                
                // If we've entered a new day
                if (gameState.lastCheckIn && gameState.lastCheckIn !== currentDay) {
                    processMissedTasks();
                    checkStreak();
                    renderAll();
                }
            }, 60000); // Check every minute
        }

        function processMissedTasks() {
            const recurringTasks = gameState.tasks.filter(t => t.recurring && isTaskActiveToday(t));
            const missedTasks = recurringTasks.filter(t => !t.completed);
            
            // Subtract XP for each missed recurring task (half of what it would give)
            missedTasks.forEach(task => {
                const penalty = Math.floor(getTaskXP() / 2);
                subtractXP(penalty);
            });
            
            if (missedTasks.length > 0) {
                saveGameState();
            }
        }

        // Achievement checking functions
        function checkConsecutiveGoodDays(days) {
            const dates = Object.keys(gameState.dailyHistory).sort();
            let consecutive = 0;
            
            for (let i = dates.length - 1; i >= 0; i--) {
                const rating = gameState.dailyHistory[dates[i]].rating;
                if (rating === 'green' || rating === 'yellow') {
                    consecutive++;
                    if (consecutive >= days) return true;
                } else if (rating !== 'none') {
                    break; // Stop at first bad day
                }
            }
            
            return false;
        }

        function checkConsecutivePerfectDays(days) {
            const dates = Object.keys(gameState.dailyHistory).sort();
            let consecutive = 0;
            
            for (let i = dates.length - 1; i >= 0; i--) {
                const rating = gameState.dailyHistory[dates[i]].rating;
                if (rating === 'green') {
                    consecutive++;
                    if (consecutive >= days) return true;
                } else {
                    break;
                }
            }
            
            return false;
        }

        function checkFullMonthPerfect() {
            // Check if any complete calendar month has all green days
            const monthData = {};
            
            Object.keys(gameState.dailyHistory).forEach(dateKey => {
                const [year, month] = dateKey.split('-');
                const key = `${year}-${month}`;
                if (!monthData[key]) monthData[key] = [];
                monthData[key].push(gameState.dailyHistory[dateKey]);
            });
            
            for (const monthKey in monthData) {
                const [year, month] = monthKey.split('-');
                const daysInMonth = new Date(parseInt(year), parseInt(month), 0).getDate();
                const monthDays = monthData[monthKey];
                
                // Must have data for every day of the month
                if (monthDays.length === daysInMonth) {
                    // All must be green and none can be 'none'
                    if (monthDays.every(day => day.rating === 'green')) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Celebrations
        function showCelebration(title, message, icon = 'üéâ') {
            document.getElementById('celebrationIcon').textContent = icon;
            document.getElementById('celebrationTitle').textContent = title;
            document.getElementById('celebrationMessage').textContent = message;
            document.getElementById('celebration').classList.add('show');
            document.getElementById('overlay').classList.add('show');
        }

        function closeCelebration() {
            document.getElementById('celebration').classList.remove('show');
            document.getElementById('overlay').classList.remove('show');
        }

        // Notification Functions
        async function requestNotificationPermission() {
            if (!('Notification' in window)) {
                alert('This browser does not support notifications');
                return;
            }
            
            const permission = await Notification.requestPermission();
            if (permission === 'granted') {
                gameState.notificationsEnabled = true;
                await saveGameState();
                updateNotificationStatus();
                scheduleAllNotifications();
                alert('Notifications enabled! You\'ll be reminded when tasks are scheduled.');
            }
        }

        function checkNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'granted') {
                gameState.notificationsEnabled = true;
            }
            updateNotificationStatus();
        }

        function updateNotificationStatus() {
            const status = document.getElementById('notificationStatus');
            const btn = document.getElementById('notificationToggleBtn');
            if (status) {
                status.textContent = gameState.notificationsEnabled 
                    ? 'Notifications enabled ‚úì' 
                    : 'Notifications disabled';
                status.style.color = gameState.notificationsEnabled ? '#51cf66' : '#666';
            }
            if (btn) {
                if (gameState.notificationsEnabled) {
                    btn.textContent = 'üîï Disable Notifications';
                    btn.style.background = '#e03131';
                    btn.onclick = disableNotifications;
                } else {
                    btn.textContent = 'üîî Enable Notifications';
                    btn.style.background = '';
                    btn.onclick = requestNotificationPermission;
                }
            }
        }

        async function disableNotifications() {
            gameState.notificationsEnabled = false;
            // Clear all scheduled notification timeouts
            gameState.scheduledNotifications.forEach(n => {
                if (n.timeoutId) clearTimeout(n.timeoutId);
            });
            gameState.scheduledNotifications = [];
            await saveGameState();
            updateNotificationStatus();
        }

        function scheduleNotification(task, batch = false) {
            if (!task.notification || !task.time || !gameState.notificationsEnabled) return;
            
            const [hours, minutes] = task.time.split(':');
            const now = new Date();
            const scheduledTime = new Date();
            scheduledTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
            
            // If time has passed today, schedule for tomorrow
            if (scheduledTime <= now) {
                scheduledTime.setDate(scheduledTime.getDate() + 1);
            }
            
            const delay = scheduledTime.getTime() - now.getTime();
            
            const timeoutId = setTimeout(() => {
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification('ScheduleBuddy Reminder', {
                        body: task.name,
                        icon: '‚úì',
                        tag: `task-${task.id}`
                    });
                }
                
                // Remove this timeout from scheduled list
                gameState.scheduledNotifications = gameState.scheduledNotifications.filter(
                    s => s.taskId !== task.id
                );
                
                // Reschedule for next day if recurring
                if (task.recurring) {
                    scheduleNotification(task);
                } else {
                    saveGameState();
                }
            }, delay);
            
            // Store scheduled notification info (not the timeout itself, but the scheduling details)
            const existingIndex = gameState.scheduledNotifications.findIndex(s => s.taskId === task.id);
            const notificationInfo = {
                taskId: task.id,
                scheduledFor: scheduledTime.getTime()
            };
            
            if (existingIndex >= 0) {
                gameState.scheduledNotifications[existingIndex] = notificationInfo;
            } else {
                gameState.scheduledNotifications.push(notificationInfo);
            }
            
            if (!batch) saveGameState();
        }

        function scheduleAllNotifications() {
            gameState.scheduledNotifications = [];
            
            gameState.tasks.forEach(task => {
                if (task.notification && task.time) {
                    scheduleNotification(task, true); // batch: skip per-task save
                }
            });
            
            saveGameState(); // single write after all notifications are set up
        }

        // Backup and Restore Functions
        function exportData() {
            const dataStr = JSON.stringify(gameState, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `schedulebuddy-backup-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            
            showCelebration('Data Exported! üíæ', 'Your progress has been saved to a file.');
        }

        async function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Validate the data has the required fields
                    if (importedData.level !== undefined && importedData.tasks !== undefined) {
                        gameState = importedData;
                        await saveGameState();
                        scheduleAllNotifications();
                        renderAll();
                        showCelebration('Data Restored! üì•', 'Your progress has been restored successfully.');
                    } else {
                        alert('Invalid backup file format');
                    }
                } catch (error) {
                    alert('Error reading backup file: ' + error.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset file input
        }

        function clearAllData() {
            if (confirm('‚ö†Ô∏è This will delete ALL your data including tasks, progress, and achievements. This cannot be undone. Are you sure?')) {
                localStorage.removeItem('scheduleBuddyGameState');
                location.reload();
            }
        }

        // Handle Enter key in task input
        document.addEventListener('DOMContentLoaded', () => {
            const modalTaskName = document.getElementById('modalTaskName');
            if (modalTaskName) {
                modalTaskName.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        saveTask();
                    }
                });
            }
            
            // Close modals when clicking overlay
            document.getElementById('overlay').addEventListener('click', () => {
                closeTaskModal();
                closeCelebration();
                closeDayPopup();
                closeAchievementPopup();
                closeDeleteConfirm();
                closeEditTaskModal();
            });
        });

        // Share Streak Progress
        function shareStreakProgress() {
            // Get the last 7 days of history
            const today = new Date();
            const last7Days = [];
            
            for (let i = 6; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                const dateKey = formatDateKey(date);
                const dayData = gameState.dailyHistory[dateKey];
                
                let emoji;
                if (dateKey === formatDateKey(today)) {
                    // Today - use current status
                    const recurringTasks = gameState.tasks.filter(t => t.recurring);
                    const totalTasks = recurringTasks.length;
                    if (totalTasks === 0) {
                        emoji = '‚¨ú';
                    } else {
                        const percentage = gameState.completedToday / totalTasks;
                        if (percentage === 1) emoji = 'üü©';
                        else if (percentage >= 0.75) emoji = 'üü®';
                        else if (percentage >= 0.5) emoji = 'üüß';
                        else emoji = 'üü•';
                    }
                } else if (!dayData || dayData.rating === 'none') {
                    emoji = '‚¨ú';
                } else {
                    if (dayData.rating === 'green') emoji = 'üü©';
                    else if (dayData.rating === 'yellow') emoji = 'üü®';
                    else if (dayData.rating === 'orange') emoji = 'üüß';
                    else if (dayData.rating === 'red') emoji = 'üü•';
                    else emoji = '‚¨ú';
                }
                
                last7Days.push(emoji);
            }
            
            // Calculate total days tracked (for "Day X")
            const totalDays = Object.keys(gameState.dailyHistory).length + 1; // +1 for today
            
            // Build the share message
            const shareText = `ScheduleBuddy - Day ${totalDays}

${last7Days.join('')}

Current Streak: ${gameState.currentStreak} Days
Best Streak: ${gameState.bestStreak} Days`;
            
            // Copy to clipboard
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareText).then(() => {
                    showCelebration('Copied to Clipboard! üìã', 'Share your streak with friends!', 'üì§');
                }).catch(err => {
                    fallbackCopyToClipboard(shareText);
                });
            } else {
                fallbackCopyToClipboard(shareText);
            }
        }

        // Share Monthly Progress
        function shareMonthlyProgress() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            
            const month = gameState.currentCalendarMonth;
            const year = gameState.currentCalendarYear;
            const monthName = monthNames[month];
            
            // Get first day of month and total days
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const today = new Date();
            const todayKey = formatDateKey(today);
            
            // Build the calendar grid
            let calendarLines = [];
            let currentLine = '';
            
            // Add empty squares for days before month starts
            for (let i = 0; i < firstDay; i++) {
                currentLine += '‚¨ú';
            }
            
            // Add days of the month
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                const dateKey = formatDateKey(date);
                const dayData = gameState.dailyHistory[dateKey];
                
                let emoji;
                if (dateKey === todayKey) {
                    // Today - use current status
                    const recurringTasks = gameState.tasks.filter(t => t.recurring);
                    const totalTasks = recurringTasks.length;
                    if (totalTasks === 0) {
                        emoji = '‚¨ú';
                    } else {
                        const percentage = gameState.completedToday / totalTasks;
                        if (percentage === 1) emoji = 'üü©';
                        else if (percentage >= 0.75) emoji = 'üü®';
                        else if (percentage >= 0.5) emoji = 'üüß';
                        else emoji = 'üü•';
                    }
                } else if (date > today) {
                    // Future days
                    emoji = '‚¨ú';
                } else if (!dayData || dayData.rating === 'none') {
                    // Past days with no tasks
                    emoji = '‚¨ú';
                } else {
                    // Past days with ratings
                    if (dayData.rating === 'green') emoji = 'üü©';
                    else if (dayData.rating === 'yellow') emoji = 'üü®';
                    else if (dayData.rating === 'orange') emoji = 'üüß';
                    else if (dayData.rating === 'red') emoji = 'üü•';
                    else emoji = '‚¨ú';
                }
                
                currentLine += emoji;
                
                // Start new line after Sunday (day 0) or if we hit 7 days
                if ((firstDay + day) % 7 === 0) {
                    calendarLines.push(currentLine);
                    currentLine = '';
                }
            }
            
            // Add remaining line if not empty
            if (currentLine) {
                calendarLines.push(currentLine);
            }
            
            // Calculate perfect days this month
            let perfectDaysThisMonth = 0;
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                if (date > today) break; // Don't count future days
                
                const dateKey = formatDateKey(date);
                const dayData = gameState.dailyHistory[dateKey];
                
                if (dateKey === todayKey) {
                    // Check if today is perfect
                    const recurringTasks = gameState.tasks.filter(t => t.recurring);
                    const totalTasks = recurringTasks.length;
                    if (totalTasks > 0 && gameState.completedToday === totalTasks) {
                        perfectDaysThisMonth++;
                    }
                } else if (dayData && dayData.rating === 'green') {
                    perfectDaysThisMonth++;
                }
            }
            
            // Calculate total perfect days
            const totalPerfectDays = Object.values(gameState.dailyHistory).filter(day => day.rating === 'green').length;
            // Add today if it's perfect
            const recurringTasks = gameState.tasks.filter(t => t.recurring);
            const totalTasks = recurringTasks.length;
            const todayIsPerfect = totalTasks > 0 && gameState.completedToday === totalTasks;
            const adjustedTotal = todayIsPerfect ? totalPerfectDays + 1 : totalPerfectDays;
            
            // Build the share message
            const shareText = `ScheduleBuddy - ${monthName}

${calendarLines.join('\n')}

Perfect Days This Month: ${perfectDaysThisMonth}
Total Perfect Days: ${adjustedTotal}`;
            
            // Copy to clipboard
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareText).then(() => {
                    showCelebration('Copied to Clipboard! üìã', 'Share your progress with friends!', 'üì§');
                }).catch(err => {
                    // Fallback for older browsers
                    fallbackCopyToClipboard(shareText);
                });
            } else {
                fallbackCopyToClipboard(shareText);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                showCelebration('Copied to Clipboard! üìã', 'Share your progress with friends!', 'üì§');
            } catch (err) {
                alert('Failed to copy. Please try again.');
            }
            
            document.body.removeChild(textArea);
        }

        // Start the app
        init();
    </script>
</body>
</html>
